type CalculateTopDownResponse {
  metricToDistributionMapList: [MetricToDistributionMap]
}

type ContextDataEntity {
  context(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String!]!
  "ISO-8601"
  creationTime: DateTime!
  entityType: EntityType!
  id: String
  regex: String!
  "ISO-8601"
  validFrom: DateTime
  "ISO-8601"
  validUntil: DateTime
}

type ContextTestResponse {
  context(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String!]!
  entityType: EntityType!
}

type Entry_String_String {
  key: String
  value: String
}

type MetricHistory {
  context(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]!
  name: String!
  "ISO-8601"
  times: [DateTime]!
  values: [Float]!
}

type MetricNameEntity {
  aggregationType: String!
  "ISO-8601"
  lastSeen: DateTime!
  metricName: String!
}

type MetricToDistributionMap {
  metric: String
  nameToPriceList: [NameToPrice]
}

"Mutation root"
type Mutation {
  deleteContextData(request: ContextDataDeleteRequestInput): ContextDataEntity
  deletePricingRule(request: PricingRuleDeleteRequestInput): PricingRuleEntity
  reprocess(
    areYouSure: String!,
    "ISO-8601"
    startTime: DateTime
  ): String!
  saveContextData(request: ContextDataSaveRequestInput): ContextDataEntity!
  savePricingRule(request: PricingRuleSaveRequestInput): PricingRuleEntity!
}

type NameToPrice {
  name: String
  price: Float
}

type PricingRuleEntity {
  baseCost: Float!
  costFactor: Float!
  "ISO-8601"
  creationTime: DateTime!
  metricName: String!
}

"Query root"
type Query {
  calculateTable(request: CalculateTopDownRequestInput): TableResponse!
  calculateTopDown(request: CalculateTopDownRequestInput): CalculateTopDownResponse!
  contextData: [ContextDataEntity!]!
  contextTest(testString: String): [ContextTestResponse!]!
  currentUser: String!
  existingContextKeys: [String!]!
  history(
    "ISO-8601"
    from: DateTime!,
    groupByContextKeys: [String]!,
    metricNames: [String]!,
    "ISO-8601"
    to: DateTime
  ): [MetricHistory!]!
  metricContextKeys: [String!]!
  metricNames: [MetricNameEntity!]!
  pricingRules: [PricingRuleEntity!]!
}

type TableEntry {
  context: [String]
  initialMetricName: String
  percentage: Float!
  total: Float!
}

type TableResponse {
  entries: [TableEntry]
}

enum EntityType {
  PRINCIPAL
  TOPIC
  UNKNOWN
}

"Scalar for BigDecimal"
scalar BigDecimal

"Scalar for BigInteger"
scalar BigInteger

"Scalar for DateTime"
scalar DateTime

input CalculateTopDownRequestInput {
  contextKeysToGroupBy: [String]
  "ISO-8601"
  from: DateTime
  kafkaNetworkReadCents: Int
  kafkaNetworkWriteCents: Int
  kafkaStorageCents: Int
  "ISO-8601"
  to: DateTime
  totalCents: Int
}

input ContextDataDeleteRequestInput {
  id: String!
}

input ContextDataSaveRequestInput {
  context: [Entry_String_StringInput!]!
  entityType: EntityType!
  id: String
  regex: String!
  "ISO-8601"
  validFrom: DateTime
  "ISO-8601"
  validUntil: DateTime
}

input Entry_String_StringInput {
  key: String
  value: String
}

input PricingRuleDeleteRequestInput {
  metricName: String!
}

input PricingRuleSaveRequestInput {
  baseCost: Float!
  costFactor: Float!
  metricName: String!
}
